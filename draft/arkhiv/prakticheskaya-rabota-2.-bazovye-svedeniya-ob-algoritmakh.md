# Практическая работа 2. Базовые сведения об алгоритмах

Зачем изучать алгоритмы? Для программиста существуют две причины: практическая и теоретическая. С практической точки зрения он должен иметь представление о стандартном наборе основных алгоритмов, относящихся к разным областям компьютерных наук. Кроме того, он должен ументь разрабатывать новые алгоритмы и анализировать их эффективность. С теоретической точки зрения процесс изучения алгоритмов, который иногда называют **алгоритмикой** \(**algorithmics**\), считается краеугольным камнем **computer science**. 

Алгоритмом называется любой набор инструкций для выполнения некоторой задачи. В принципе, любой фрагмент программного кода можно назвать алгоритмом.

> Если говорить более строго, то алгоритм - это последовательность четко определенных инструкций, предназначенных для решения некоторой задачи. Другими словами, это последовательность команд, позволяющих получить из корректных входных данных требующиеся выходные данные за ограниченный промежуток времени.

### Бинарный поиск

Предположим, вы ищете фамилию человека в бумажной телефонной книге. Она начинается с буквы "К". Конечно, можно начать с самого начала и перелистывать страницы, пока не доберетесь до буквы "К". Но скорее всего для ускорения поиска лучше раскрыть книгу на середине: ведь буква "К" должна находиться где-то ближе к середине телефонной книги.

Или предполождим, что вы ищете слово в словаре и оно начинается с буквы "О". И снова лучше начать с середины.

Теперь допустим, что вы вводите свои данные при входе в Facebook. При этом Facebook необходимо проверить, есть ли ваша учетная запись на сайте. Для этого ваше имя пользователя нужно найти в базе данных. Допустим, вы выбрали себе имя пользователя "karl99". Facebook может начать с буквы A и проверять все подряд, но разумнее будет начать с середины.

Перед нами типичная задача поиска. И во всех этих случаях для решения задачи можно применить один алгоритм: бинарный поиск.

**Бинарный поиск** - это алгоритм; на входе он получает остортированный список элементов \(это необходимое условие для алгоритма бинарного поиска\). Если элемент, который вы ищете, присутствует в списке, то бинарный поиск возвращает ту позицию, в которой он был найден. В противном случае бинарный поиск возвращает `None`.

Рассмотрим пример того, как работает бинарный поиск. Представьте себе, что вы играете с приятелем в игру "Угадай число от 1 до 100".

Вы должны угадать число, использовав как можно меньше попыток. При каждой попытке приятель будет давать один из трех ответов: "мало", "много" и "угадал!".

Предположим, вы начнете перебирать все варианты подряд: 1, 2, 3, 4, ... .

Это пример простого поиска \(он еще называется "линейный поиск"\). При каждой догадке исключается только одно число. Если приятель загадал число 99, то, чтобы добраться до него, потребуется 99 попыток.

Существует другой, более эффективный способ. 

Начнем с 50. Если приятель говорит "мало", то мы исключаем половину чисел из всего диапазона \(от 1 до 100\). Теперь вы знаете, что все числа 1 - 50 меньше загаданного. Следующая попытка: 75.

Приятель говорит "много". Но мы снова исключаем половину оставшихся чисел \(числа от 75 до 100 гарантированно будут больше, чем загаданное число\).

**С бинарным поиском вы каждый раз загадываете число в середине диапазона и исключаете половину оставшихся чисел.**

Следующим будет число 63 \(посередине между 50 и 75\).

Так работает бинарный поиск. Попробуем точнее определить, сколько чисел будет исключаться каждый раз.

![](../../.gitbook/assets/image%20%2844%29.png)

Какое бы число не задумывал ваш приятель, вы гарантированно сможете угадать его не более чем за 7 попыток, потому что с каждой попыткой исключается половина оставшихся чисел.

Предположим, что вы ищете слово в словаре с 240 000 словами. Как вы думаете, сколько попыток вам понадобится в худшем случае?

При простом поиске может понадобится 240 000 попыток, если искомое слово находится на самой последней позиции в словаре. С каждым шагом бинарного поиска количество слов сокращается вдвое, пока не останется только одно слово.

![](../../.gitbook/assets/image%20%2843%29.png)

Итак, бинарный поиск потребует 18 шагов - заметная разница! В общем случае для списка из `n` элементов бинарный поиск выполняется за

$$
log_2n
$$

шагов, тогда как простой поиск будет выполняться за `n` шагов.

#### Логарфимы

Выражение 

$$
log_{10}  100
$$

по сути ознчает, сколько раз нужно перемножить 10, чтобы получить 100. Правильный ответ равен 2: `10 * 10 = 100`. Таким образом

$$
log_{10}  100 =  2
$$

Логарифм по смыслу противоположен возведению в степень.

$$
10^2 = 100 \; ; \; log_{10}100 = 2 \\
10^3 = 1000 \; ; \; log_{10}1000 = 3 \\
2^3 = 8 \; ; \; log_{2}8= 3 \\
2^4 = 16 \; ; \; log_{2}8= 4 \\
2^5 = 32 \; ; \; log_{2}32 = 5 \\
$$

Когда впредь будет упоминаться `log`, то это почти всегда означает логарифм по основанию 2.

{% hint style="info" %}
Бинарный поиск работает только в том случае, если список отсортирован. Например, имена в телефонной книге хранятся в алфавитном порядке, и вы можете воспользоваться бинарным поиском. А что произойдет, если имена не будут отсортированы?
{% endhint %}

### Время выполнения

Каждый раз, когда мы будем рассматривать очередной алгоритм, мы будем обсуждать время его выполнения. Обычно следует выбирать самый эффективный алгоритм, будь то оптимизация по времени выполнения или оптимизация по используемой памяти.

Сколько времени сэкономит применение бинарного поиска. В случае линейного поиска мы проверяли каждое число, одно за другим. Если список состоит из 100 элементов, может потребоваться до 100 попыток. Для списка из 4 миллиардов чисел потребуется до 4 миллиардов попыток. Таким образом, максимальное количество попыток совпадает с размером списка. Такое время выполнения называется **линейным**.

С бинарным поиском дело обстоит иначе. Если список состоит из 100 элементов, потребуется не более 7 попыток. Для списка из 4 миллиардов элементов потребуется не более 32 попыток. Таким образом, бинарный поиск выполняется за **логарифмическое время**.

| Простой поиск | Бинарный поиск |
| :--- | :--- |
| 100 элементов -&gt; 100 попыток | 100 элементов -&gt; 7 попыток |
| 4 000 000 000 элементов -&gt; 4 000 000 000 попыток | 4 000 000 000 элементов -&gt; 32 попытки |
| `O(n)` | `O(log n)` |

### "О большое"

Специальная нотация "O большое" описывает скорость работы алгоритма. Зачем нам это? Время от времени нам придется использовать чужие алгоритмы, а потому было бы здорово понимать, насколько быстро или медленно они работают.

#### Время выполнения алгоритмов растет с разной скоростью



