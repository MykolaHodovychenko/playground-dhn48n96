# Условное выполнение

## Булевы выражения

Часто в реальной жизни мы соглашаемся с каким-либо утверждением или отрицаем его. Например, если вам скажут, что сумма чисел 3 и 5 больше 7, вы согласитесь, скажете: "Да, это правда". Если же кто-то будет утверждать, что сумма трех и пяти меньше семи, то вы расцените такое утверждение как ложное.

Подобные фразы предполагают только два возможных ответа - либо "да", когда выражение оценивается как правда, истина, либо "нет", когда утверждение оценивается как ошибочное, ложное. В программировании и математике **если результатом вычисления выражения может быть лишь истина или ложь, то такое выражение называется логическим**.

Например, выражение 4 &gt; 5 является логическим, так как его результатом является либо правда, либо ложь. Выражение 4 + 5 не является логическим, так как результатом его выполнения является число.

Мы уже знакомы с некоторыми типами данных - с целыми и вещественными числами, а также со строками. Теперь мы введем четвертый тип - **логический тип данных** \(тип **bool**\). Его также называют булевым. У этого типа всего два возможных значения: **True** \(правда\) и **False** \(ложь\).

{% hint style="info" %}
Булева алгебра является алгеброй логики. Она имеет дело с переменными, которые могут иметь два значения: **0\(False\)** или **1\(True\)** и с операциями, которые имеют логическое значение.

Самый ранний метод манипулирования символической логикой был изобретен Джорджем Булем и впоследствии стал известен как Булева алгебра. В настоящее время булева алгебра стала незаменимым инструментом в области компьютерных наук.
{% endhint %}

Запустим Python и попробуем разобраться с логическим типом данных

```python
>>> a = True
>>> type(a)
<class 'bool'>

>>> b = False
>>> type(b)
<class 'bool'>
```

Здесь переменной a было присвоено значение True, после чего с помощью встроенной в Python функции type\(\) был проверен ее тип. Python сообщил, что это переменная типа bool. Переменная b также является булевой.

В программировании False обычно приравнивают к нулю, а True - к единице. Чтобы в этом убедиться, можно преобразовать булево значение к целочисленному типу

```python
>>> int(True)
1
>>> int(False)
0
```

Возможно и обратное. Можно преобразовать какое-либо значение к булевому типу

```python
>>> bool(3.14)
True
>>> bool(-100)
True
>>> bool(0)
False
>>> bool(" ")
True
>>> bool("Привет!")
True
>>> bool("")
False
```

Здесь работает правило: все, что не 0 и не пустота, является правдой.

### Логические операторы

Говоря на естественном языке, мы обозначаем сравнения словами "равно", "больше", "меньше". В языках программирования используются специальные знаки, подобные тем, которые используются в математике. 

Простые логические операторы часто называют **операторами сравнения**. Рассмотрим операторы сравнения в Python

| Оператор | Значение |
| :--- | :--- |
| &lt; | меньше \(строгое неравенство, 3 &lt; 5 равно True\) |
| &lt;= | меньше либо равно \(нестрогое неравенство, 3 &lt; 5 равно True, 3 &lt;= 3 равно True\)  |
| &gt; | больше \(строгое неравенство, 5 &gt; 3 равно True\) |
| &gt;= | больше либо равно \(нестрогое неравенство, 5 &gt; 3 равно True, 5 &gt;= 5 равно True\) |
| == | равенство \(3 == 3 равно True, 4 == 3 равно False\) |
| != | не равно \(3 != 3 равно False, 4 != 3 равно True\) |
| is | равно \(используется для переменных и объектов\) |
| is not | не равно \(используется для переменных и объектов\) |
| in | вхождение значения в последовательность \(будет рассмотрено позже\) |
| not in | не вхождение значения в последовательность \(будет рассмотрено позже\) |

#### Приоритет операторов сравнения и арифметических операторов

Если расположить операторы сравнения в порядке убывания приоритета , то мы получим следующую картину

* &lt;. &lt;=, &gt;=, &gt;
* ==, !=, is, is not, in
* not in

{% hint style="warning" %}
Важно! Арифметические операторы имеют приоритет выше, чем операторы сравнения.
{% endhint %}

Важно помнить и понять принципы выстраивания приоритета операций в языках программирования.

```python
>>> 10 > 3 + 6
True

>>> a = 5
>>> a < 4 + 1
False

>>> 100 < 4 * 20 + 30
True
```

При вычислении значений выражений, сначала будут вычисляться выражения с арифметическими операторами, после чего будут вычисляться выражения с логическими операторами.

